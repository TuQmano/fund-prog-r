---
title: "Fundamentos de la programación estadística y Data Mining en R"
author: "Dr. Germán Rosati (Digital House - UNTREF - UNSAM)"
output:
  beamer_presentation:
    colortheme: whale
    fig_caption: yes
    fonttheme: professionalfonts
    highlight: tango
    theme: JuanLesPins
subtitle: "Unidad 4. Reglas de Decisión y Market Basket Analysis"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Cuestiones generales sobre Reglas de Decisión
- En general, pueden pensarse como un conjunto de condiciones del tipo "si X => Y" 
- Muchas aplicaciones: recomendación de productos, diagnósticos médicos, etc.

# Algunas definiciones
- Podemos representar el conjunto items (en este caso, productos) de la siguiente forma:
$I = \{i_{1},i_{2},i_{3},...,i_{n}\}$
- De esta forma, una transacción (compra) puede ser representada de la siguiente forma:
$t_{n} = \{i_{1}, i_{2}, ..., i_{n}\}$
- Y el conjunto de todas las transacciones puede ser representado como 
$D = \{t_{1}, t_{2},...t_{m}\}$
- Cada transacción $t_{i}$ en $D$ tiene un único identificador y contiene un determinado conjunto (subset) de items en $I$.


# Algunas definiciones
- El objetivo es construir "reglas".
- Cada regla tiene dos elementos (o dos conjuntos de items) llamados "antecedente" o _Left-Hand-Side_ (LHS) y consecuente o _Right-Hand-Side_ (RHS)
- A partir del análisis de las transacciones el objetivo será encontrar reglas del tipo:
$\{café, verdura\} \Rightarrow {carne}$
- Supongamos que $X$ es un conjunto de items, $X \Rightarrow Y$ es un conjunto de reglas y $T$ un conjunto de transacciones en una base de datos determinada

# Algunos indicadores importantes
- *Support:*  la frecuencia relativa en la que el conjunto de items aparece. Es la proporción de transacciones $t$ que contienen el itemset $X$ 

$$supp(X) = \frac{|\{ t \in T; X \subseteq t \}|}{|T|}$$
- En muchas situaciones puede ser útil buscar por support alto. Sin embargo, en otros un support bajo puede ser de interés para hallar relaciones escondidas.

# Algunos indicadores importantes
- *Confidence:* es una medida de confianza de la regla, es decir, cuántas veces la regla aparece como verdadera. El valor de confidence de una regla $X \Rightarrow Y$ con respecto a un set de transacciones $T$ es la proporción de transacciones que contienen a $X$ y también a $Y$. Puede definirse como:

$$conf(X \Rightarrow Y) = \frac{supp(X \cup Y)}{supp(X)} $$
- Un confidence de .5 implicaría que en el 50% de los casos se produce la regla. Para recomendación de productos un confidence de 50% puede ser aceptable.

# Algunos indicadores importantes
- *Lift:* es la razón entre el support observado y el esperada si las reglas fuesen independientes. 
$$lift(X \Rightarrow Y) = \frac{supp(X \cup Y)}{supp(X)*supp(Y)}$$
- La regla de aproximación es que si el lift está cercano a 1, las reglas son indpendientes. Un lift > 1 puede ser indicativo de una regla útil. Quiere decir que las dos ocurrencias son dependientes una de otra (en algún grado) y por lo tanto pueden hacer a la regla potencialmente útil para predecir la ocurrencia del consecuente en otro dataset.

# Parámetros
- En general, se requiere la definición por parte del usuario de dos parámetros:
        + un _support_ mínimo para encontrar todos los         itemsets frecuentes
        + una restricción de _confidence_ mínima para         los itemsets que cumplen la condición anterior         para poder formar reglas
- Encontrar todos los itemsets frecuentes en un dataset es comokejo: requiere buscar en todos los posibles itemsets (todas las combinaciones posibles)-
- El conjunto de todos los itemsets posibles es una ptencia de $I$, aproximadamente $2^n-1 2^n-1$. Es decir, crece exponencialmente de acuerdo al tamaño de $I$.
- Es posible usar búsquedas eficientes usando algunos algoritmos, como el llamado "a priori".
- En R lo implementaremos con el paquete `arules`

# Implementación en R: queries en SQL desde R
- Previamente, vamos a introducir dos librerías para realizar consultas SQL desde R.
- `RSQLite`: para conectarse a SQLite
- `DBI`: interfaces genérica para varios motores
-  Hay que generar un objeto conexión con `dbConnect()` y pasarle algunos argumentos: `drv`: driver correspondiente (por ejemplo, `RSQLite::SQLite()`)
- SQLite solamente requiere `drv`, otros pueden requerir más detalles (`password`, `host`, `port`, etc.)
- [Más detalles...](https://cran.r-project.org/web/packages/DBI/DBI.pdf)

# Implementación en R: ejemplo en SQLite
```{r, collapse=TRUE, highlight=TRUE, prompt=FALSE, strip.white=FALSE, tidy=FALSE, echo=TRUE}
library(DBI)
library(RSQLite)
setwd("/home/digitalhouse/Documentos/Kaggle - Instacart")
con <- dbConnect(RSQLite::SQLite(), 
                 dbname="instacart_kaggle.db")
```

# Implementación en R: ejemplo en SQLite
```{r, collapse=TRUE, highlight=TRUE, prompt=TRUE, strip.white=FALSE, tidy=TRUE, echo=TRUE}
dbListTables(con)
df<-dbGetQuery(con,'SELECT * FROM orders LIMIT 10')
```
